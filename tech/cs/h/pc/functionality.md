---
layout: '@layout/Layout.astro'
---
# [単一プロセッサ](/b/cs/h/pc/f-singleProcessor)
## 1. [逐次制御方式](/b/cs/h/pc/f-sequentialControl)
1ステージずつ命令を実行し、一つの命令が完了したら次の命令を実行する。<br>問題: 一つの命令をしている間、他のステージで使うCPUは何もしていないので無駄が多い。

## 2. [パイプライン方式](/b/cs/h/pc/f-pipeline)
トヨタ生産方式のような流れ作業をプロセッサ上で行う。<br>
問題: パイプライン処理が、以上に書いたようにスムーズに進めば良いが、分岐命令を実行すると、途中から命令が二つになったり、ある命令の実行内容がそれ以前の命令の実行結果に依存するものだったりする場合、処理が乱れてしまう。このようなpipline hazardを特に制御ハザード(分岐ハザード)という。

## 3. [スーパパイプライン・スーパスカラ](/b/cs/h/pc/f-pipeline)
パイプラインをさらに強化する2つの方法。
* [スーパパイプライン](/b/cs/h/pc/f-pipeline#SuperPipeline)は処理を細分化することによって、
* [スーパスカラ](/b/cs/h/pc/f-pipeline#SuperScholar)は同時に処理するユニットの数を増やすことによって、<br>強化する。

## 4. [VLIW](/b/cs/h/pc/f-vliw)
プログラムのコンパイルの段階で、一つの長い命令にする。
# [複数プロセッサ/並行プロセッサシステム](/b/cs/h/pc/f-parallelProcessing)
以上のように、個々のプロセッサの性能を上げるだけでは総合的な性能の向上は見込めなくなってきた。そこで、複数のプロセッサをつなげることで高速化を図る。
# [バイトオーダー](/b/cs/h/pc/biteOrder)
命令データ(処理・オペランド)がどのようにCPUや主記憶装置の間でやり取りされる際、データを格納する順番(方向)が異なります。なぜそのようなことが起きているのか、どのように使い分けられているのか理解します。